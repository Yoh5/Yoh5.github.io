{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RTYPE_DOCUMENTATION This is about the full documentation of RTYPE project R-TYPE This Advanced C++ knowledge unit project enables the development of networked video games and provides an opportunity to explore advanced development techniques and learn good software engineering practices. The aim is to implement a multithreaded server and a graphical client for a well-known existing video game called R-Type, using a game engine of your own design. Home Compilation_and_Running Server Client","title":"Home"},{"location":"#welcome-to-rtype_documentation","text":"This is about the full documentation of RTYPE project","title":"Welcome to RTYPE_DOCUMENTATION"},{"location":"#r-type","text":"This Advanced C++ knowledge unit project enables the development of networked video games and provides an opportunity to explore advanced development techniques and learn good software engineering practices. The aim is to implement a multithreaded server and a graphical client for a well-known existing video game called R-Type, using a game engine of your own design. Home Compilation_and_Running Server Client","title":"R-TYPE"},{"location":"About/","text":"Team Information The team that works on this project is made up of 5 members: Aurel AZON Fid\u00e9lia Sowakoude Fitzgerald ADECHIAN Milohoue AHO Sedjro HOUNDONOUGBO","title":"About"},{"location":"About/#team-information","text":"The team that works on this project is made up of 5 members: Aurel AZON Fid\u00e9lia Sowakoude Fitzgerald ADECHIAN Milohoue AHO Sedjro HOUNDONOUGBO","title":"Team Information"},{"location":"Client/","text":"What it's all about A Client is a rendering manager that also communicate with server (send user input, receive server information) The client rendering is based on a ECS engine. So you can customize your displaying with custum entities. So, Client manage communication between server and user and also game rendering with ECS The customer has the: reception of different information sent by the server display of various asserts retrieve various user inputs and send them to the server set up an attractive client interface (GUI) integration of ECS with client How it works Run the executable r-type_client on Linux and r-type_client.exe on Windows","title":"Client"},{"location":"Client/#what-its-all-about","text":"A Client is a rendering manager that also communicate with server (send user input, receive server information) The client rendering is based on a ECS engine. So you can customize your displaying with custum entities. So, Client manage communication between server and user and also game rendering with ECS The customer has the: reception of different information sent by the server display of various asserts retrieve various user inputs and send them to the server set up an attractive client interface (GUI) integration of ECS with client","title":"What it's all about"},{"location":"Client/#how-it-works","text":"Run the executable r-type_client on Linux and r-type_client.exe on Windows","title":"How it works"},{"location":"Compile_and_Run/","text":"Dependencies CMake Installation Conan Installation Install Microsoft Visual C++ and MSBuild Tools packages Compiling and Running On Linux Run conan install . --build=missing at the root of your build directory Install the missing packages Create the directory \"build\" and go in Run cmake .. -DCMAKE_BUILD_TYPE=Release and after that run make On Windows Configure the Path for MSBuild Tools Run conan install . --build=missing -of=build at the root of your build directory Enter in the build directory with cd build Run cmake .. -DCMAKE_BUILD_TYPE=Release -G \"Visual Studio 17\" Run cmake --build . --config Release","title":"Compiling and Running"},{"location":"Compile_and_Run/#dependencies","text":"CMake Installation Conan Installation Install Microsoft Visual C++ and MSBuild Tools packages","title":"Dependencies"},{"location":"Compile_and_Run/#compiling-and-running","text":"","title":"Compiling and Running"},{"location":"Compile_and_Run/#on-linux","text":"Run conan install . --build=missing at the root of your build directory Install the missing packages Create the directory \"build\" and go in Run cmake .. -DCMAKE_BUILD_TYPE=Release and after that run make","title":"On Linux"},{"location":"Compile_and_Run/#on-windows","text":"Configure the Path for MSBuild Tools Run conan install . --build=missing -of=build at the root of your build directory Enter in the build directory with cd build Run cmake .. -DCMAKE_BUILD_TYPE=Release -G \"Visual Studio 17\" Run cmake --build . --config Release","title":"On Windows"},{"location":"Engine/","text":"WHAT IS BJENGINE Bjengine is a 2d engine written in C++ based on ECS, designed for the creation of 2d video games. It offers various modules such as: audio, network, 2d rendering, physics, etc. Rendering The engine provides a basic rendering system with support for 2D graphics. It can render sprites, textures, and text. Input Handling Capture and respond to user input including keyboard, mouse, and gamepad events. Audio Play sound effects and background music using the built-in audio system. Physics Basic support for 2D physics simulations, collisions, and interactions. HOW IT WORKS Initializing the Engine Initialize the engine by setting up the game window, configuring rendering settings, and starting the game loop. Creating Game Objects Define game objects using entities and attach relevant components to them. Controlling Game Loop Handle game logic, rendering, and input processing within the game loop. Components Transform The transform component defines the position, rotation, and scale of a game object. SpriteRenderer SpriteRenderer renders sprites and textures attached to game objects. Collider Collider components define the collision boundaries for game objects. AudioSource Attach audio sources to game objects for sound playback.","title":"BJEngine"},{"location":"Engine/#what-is-bjengine","text":"Bjengine is a 2d engine written in C++ based on ECS, designed for the creation of 2d video games. It offers various modules such as: audio, network, 2d rendering, physics, etc.","title":"WHAT IS BJENGINE"},{"location":"Engine/#rendering","text":"The engine provides a basic rendering system with support for 2D graphics. It can render sprites, textures, and text.","title":"Rendering"},{"location":"Engine/#input-handling","text":"Capture and respond to user input including keyboard, mouse, and gamepad events.","title":"Input Handling"},{"location":"Engine/#audio","text":"Play sound effects and background music using the built-in audio system.","title":"Audio"},{"location":"Engine/#physics","text":"Basic support for 2D physics simulations, collisions, and interactions.","title":"Physics"},{"location":"Engine/#how-it-works","text":"","title":"HOW IT WORKS"},{"location":"Engine/#initializing-the-engine","text":"Initialize the engine by setting up the game window, configuring rendering settings, and starting the game loop.","title":"Initializing the Engine"},{"location":"Engine/#creating-game-objects","text":"Define game objects using entities and attach relevant components to them.","title":"Creating Game Objects"},{"location":"Engine/#controlling-game-loop","text":"Handle game logic, rendering, and input processing within the game loop.","title":"Controlling Game Loop"},{"location":"Engine/#components","text":"","title":"Components"},{"location":"Engine/#transform","text":"The transform component defines the position, rotation, and scale of a game object.","title":"Transform"},{"location":"Engine/#spriterenderer","text":"SpriteRenderer renders sprites and textures attached to game objects.","title":"SpriteRenderer"},{"location":"Engine/#collider","text":"Collider components define the collision boundaries for game objects.","title":"Collider"},{"location":"Engine/#audiosource","text":"Attach audio sources to game objects for sound playback.","title":"AudioSource"},{"location":"How_to_use_Engine_based_on_ECS/","text":"How it works Our Engine is based on ECS (Entity Component System) and actually is used both on Client and Server. ` enum SYSTEM_TAG { render, event, network, update, user_handling, move, shots, destruction, }; class registry { public: using system = std::function ; using sparseArrayMap = std::unordered_map ; using systems = std::vector >; registry() { state = 0; } /*------------------------------------------>Start Component Management <-----------------------------------------------------------*/ template <class Component> void register_component() { _components_arrays[std::type_index(typeid(Component))] = std::any(sparse_array<Component>()); } template <typename Component> sparse_array<Component> &get_components() { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]); } template <typename Component> Component &get_component(entity entt) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return *(std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]))[entt]; } template <typename Component> void attach_component(entity entt, Component component) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to insert not exist\" << std::endl; throw std::exception(); } std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).insert_at(entt, component); } template <typename... Args> void attach_components(entity entt, Args... args) { ((attach_component(entt, args)), ...); } template <class Component> void detach_component(entity entt, Component component) { std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).erase(entt); } template <typename... Args> void detach_components(entity entt, Args... args) { ((detach_component(entt, args)), ...); } /*------------------------------------------>End Component Management <-----------------------------------------------------------*/ /*------------------------------------------>Start Entity Management <-----------------------------------------------------------*/ entity spawn_entity() { entity id; if (!killed.empty()) { id = killed.back(); killed.pop_back(); return id; } id = (_entities.empty()) ? entity(0) : entity(_entities.back() + 1); _entities.push_back(id); return id; } void kill_entity(entity entt) { killed.push_back(entt); } int entities() const { return _entities.size(); } template <typename type> static bool contains(std::vector<type> list, type element) { return (std::find(list.begin(), list.end(), element) != list.end()); } /*------------------------------------------>End Entity Management <-----------------------------------------------------------*/ /*------------------------------------------>Start System Management <-----------------------------------------------------------*/ void add_system(system const &f, SYSTEM_TAG tag) { _systems.push_back(std::make_pair(f, tag)); } void run_systems(SYSTEM_TAG tag) { for (auto const &_sys : _systems) { if (_sys.second == tag) _sys.first(*this); } } /*------------------------------------------>End Systems Management <-----------------------------------------------------------*/ bool isEntityUnusable(entity id) { return std::find(killed.begin(), killed.end(), id) != killed.end(); } void setState(int state) { this->state = state; } int getState(void) const { return state; } The main logic of ECS is based on the addition of components and customized systems, where all components of the same type are grouped together in a container. In this way, systems can more easily retrieve all the components on which they act, independently of the entities with which they are associated. This results in a consequent optimization of the program. To add a new component type, execute the register_component function. To create an entity, execute spawn_enity . And when you want to attach a component to the entity you've created, you execute attach_component . Here's an example: core.register_component<COMPONENT::Drawable>() core.register_component<COMPONENT::State>(); core.register_component<COMPONENT::Transformable>(); core.add_system(SYSTEM::render, SYSTEM_TAG::render); core.add_system(SYSTEM::manageTransformation, SYSTEM_TAG::update); core.attach_components(background, COMPONENT::Drawable(std::make_shared<sf::Sprite>(sf::Sprite(textures[0])))), COMPONENT::Transformable(sf::Vector2f(0, 0)), COMPONENT::State(0));","title":"How to use Engine based on ECS"},{"location":"How_to_use_Engine_based_on_ECS/#how-it-works","text":"Our Engine is based on ECS (Entity Component System) and actually is used both on Client and Server. ` enum SYSTEM_TAG { render, event, network, update, user_handling, move, shots, destruction, }; class registry { public: using system = std::function ; using sparseArrayMap = std::unordered_map ; using systems = std::vector >; registry() { state = 0; } /*------------------------------------------>Start Component Management <-----------------------------------------------------------*/ template <class Component> void register_component() { _components_arrays[std::type_index(typeid(Component))] = std::any(sparse_array<Component>()); } template <typename Component> sparse_array<Component> &get_components() { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]); } template <typename Component> Component &get_component(entity entt) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return *(std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]))[entt]; } template <typename Component> void attach_component(entity entt, Component component) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to insert not exist\" << std::endl; throw std::exception(); } std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).insert_at(entt, component); } template <typename... Args> void attach_components(entity entt, Args... args) { ((attach_component(entt, args)), ...); } template <class Component> void detach_component(entity entt, Component component) { std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).erase(entt); } template <typename... Args> void detach_components(entity entt, Args... args) { ((detach_component(entt, args)), ...); } /*------------------------------------------>End Component Management <-----------------------------------------------------------*/ /*------------------------------------------>Start Entity Management <-----------------------------------------------------------*/ entity spawn_entity() { entity id; if (!killed.empty()) { id = killed.back(); killed.pop_back(); return id; } id = (_entities.empty()) ? entity(0) : entity(_entities.back() + 1); _entities.push_back(id); return id; } void kill_entity(entity entt) { killed.push_back(entt); } int entities() const { return _entities.size(); } template <typename type> static bool contains(std::vector<type> list, type element) { return (std::find(list.begin(), list.end(), element) != list.end()); } /*------------------------------------------>End Entity Management <-----------------------------------------------------------*/ /*------------------------------------------>Start System Management <-----------------------------------------------------------*/ void add_system(system const &f, SYSTEM_TAG tag) { _systems.push_back(std::make_pair(f, tag)); } void run_systems(SYSTEM_TAG tag) { for (auto const &_sys : _systems) { if (_sys.second == tag) _sys.first(*this); } } /*------------------------------------------>End Systems Management <-----------------------------------------------------------*/ bool isEntityUnusable(entity id) { return std::find(killed.begin(), killed.end(), id) != killed.end(); } void setState(int state) { this->state = state; } int getState(void) const { return state; } The main logic of ECS is based on the addition of components and customized systems, where all components of the same type are grouped together in a container. In this way, systems can more easily retrieve all the components on which they act, independently of the entities with which they are associated. This results in a consequent optimization of the program. To add a new component type, execute the register_component function. To create an entity, execute spawn_enity . And when you want to attach a component to the entity you've created, you execute attach_component . Here's an example: core.register_component<COMPONENT::Drawable>() core.register_component<COMPONENT::State>(); core.register_component<COMPONENT::Transformable>(); core.add_system(SYSTEM::render, SYSTEM_TAG::render); core.add_system(SYSTEM::manageTransformation, SYSTEM_TAG::update); core.attach_components(background, COMPONENT::Drawable(std::make_shared<sf::Sprite>(sf::Sprite(textures[0])))), COMPONENT::Transformable(sf::Vector2f(0, 0)), COMPONENT::State(0));","title":"How it works"},{"location":"Server/","text":"About our server code based on the ECS architecture and game loop implementation. ECS Architecture Implementation: The ECS is dynamically registering components for entities when a new player is added to the room. While this is flexible, it might introduce runtime overhead. Typically, components are registered once, during system initialization, not per entity. Entities are assigned components such as transform , velocity , and controlable . Each of these components should be lightweight and only contain data. Logic is processed in systems, which operate on entities that have a specific set of components. Networking and Concurrency: The server uses asynchronous I/O for networking, which is a good approach for scalability. However, the shared resources, such as the rooms map, must be properly synchronized to prevent race conditions. The use of a thread pool suggests that the server is designed to handle tasks concurrently. However, task scheduling and proper synchronization are crucial to prevent deadlocks and ensure thread safety. Game Loop and Timing: The game loop runs a series of checks in a while loop, processing messages, updating game state, and sending updates to players at an 80ms interval. This timing mechanism is crucial to maintain a consistent state across the network. The server handles game cycles and manages state transitions (e.g., from running to game-over). However, it's not clear how it manages varying network latencies and time discrepancies between clients, which is critical for a multiplayer game. Resource Management: The server creates and deletes rooms dynamically. This requires efficient resource management to prevent memory leaks. C++ smart pointers are used, which is a good practice, but there should also be proper handling for other non-memory resources like network sockets. The code indicates cleanup by erasing rooms, but it\u2019s vital to ensure that all resources are released properly, including shutting down any associated threads cleanly. Game State Management: The game state is tracked using various variables and is checked periodically within the game loop. There is logic to determine if a game is won or lost, but the conditions for winning or losing are not detailed. It would be important to define and handle these conditions clearly. There's a potential issue with how the game checks for player life ( nbPAlive ). If multiple threads are modifying this value, there must be proper synchronization to prevent undefined behavior. Security and Fair Play: An IP ban list ( bannedIp ) is a basic approach to prevent malicious users from connecting. However, IP bans are easily circumvented and don't handle in-game cheating. Implementing more sophisticated cheat detection and prevention mechanisms would be beneficial. Security measures such as validating player actions to prevent cheating and verifying message integrity to protect against tampering should be considered. Logging and Monitoring: While the server does log to std::cout , for a production environment, it's important to have a more robust logging system that can handle different log levels and output to files or logging services. Monitoring metrics like totalPacketsSent and totalPacketsReceived is a good practice, but there should also be metrics for performance monitoring, such as average response time, server load, and more. Error Handling: Error handling is notably absent in the provided snippets. In a robust server, you would expect to see try-catch blocks, especially around I/O operations, to gracefully handle exceptions. Networking code should handle various failure scenarios, such as client disconnections, timeouts, and malformed packets. Scalability and Performance: The server\u2019s scalability is limited by the maxRoom count. To truly scale, the architecture could be designed to distribute rooms across multiple servers or dynamically allocate resources based on demand. For performance, the systems within the ECS should be optimized for cache coherency, minimizing overhead when iterating over entities and components. Admin Client Session This section outlines the implementation and functionality of the Admin Client Panel within the R-Type TCP Protocol. The panel is intended for administrative users to manage and interact with the server in a controlled environment. ### Startup Sequence: - The Admin Server is initiated with a welcoming message, \"Starting Admin Server...\", followed by the instantiation of the Net::AdminServer object on port 5557. The server attempts to establish a connection to the main server using provided command-line arguments, which should represent the IP address and port number, respectively. If the connection fails, an error message is displayed, and the program exits. ### Command-Line Interface (CLI): - The Admin Panel provides a command-line interface (CLI) for real-time interaction. Upon successful initiation, the admin user is prompted with admin-cli > to enter commands. The input is parsed into a vector of strings, where each string represents a command or argument. ### Command Processing: #### The CLI supports multiple commands: - stop: Terminates the admin panel. - connect: Establishes a login to the server with credentials. - listconnecteduser: Retrieves a list of currently connected users. - getuserinfo <userid>: Obtains information about a specific user by user ID. - banuser <userID>: Issues a ban on a user, preventing access to the server. - debanuser <userIP>: Lifts a ban from a user, restoring server access. - listuserbanned: Lists all users who have been banned. - getinforoom <roomID>: Fetches details about a particular room using its ID. - listroom: Lists all available rooms on the server. - allpaquets: Requests the total number of packets managed by the server. - setmaxroom <newMax>: Sets the maximum allowed rooms on the server, with constraints for valid range checks.","title":"Server"}]}