{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RTYPE_DOCUMENTATION This is about the full documentation of RTYPE project R-TYPE This Advanced C++ knowledge unit project enables the development of networked video games and provides an opportunity to explore advanced development techniques and learn good software engineering practices. The aim is to implement a multithreaded server and a graphical client for a well-known existing video game called R-Type, using a game engine of your own design. Home Compilation_and_Running Server Client","title":"Home"},{"location":"#welcome-to-rtype_documentation","text":"This is about the full documentation of RTYPE project","title":"Welcome to RTYPE_DOCUMENTATION"},{"location":"#r-type","text":"This Advanced C++ knowledge unit project enables the development of networked video games and provides an opportunity to explore advanced development techniques and learn good software engineering practices. The aim is to implement a multithreaded server and a graphical client for a well-known existing video game called R-Type, using a game engine of your own design. Home Compilation_and_Running Server Client","title":"R-TYPE"},{"location":"About/","text":"Team Information The team that works on this project is made up of 5 members: Aurel AZON Fid\u00e9lia Sowakoude Fitzgerald ADECHIAN Milohoue AHO Sedjro HOUNDONOUGBO","title":"About"},{"location":"About/#team-information","text":"The team that works on this project is made up of 5 members: Aurel AZON Fid\u00e9lia Sowakoude Fitzgerald ADECHIAN Milohoue AHO Sedjro HOUNDONOUGBO","title":"Team Information"},{"location":"Client/","text":"What it's all about A Client is a rendering manager that also communicate with server (send user input, receive server information) The client rendering is based on a ECS engine. So you can customize your displaying with custum entities. So, Client manage communication between server and user and also game rendering with ECS The customer has the: reception of different information sent by the server display of various asserts retrieve various user inputs and send them to the server set up an attractive client interface (GUI) integration of ECS with client How it works Run the executable r-type_client on Linux and r-type_client.exe on Windows","title":"Client"},{"location":"Client/#what-its-all-about","text":"A Client is a rendering manager that also communicate with server (send user input, receive server information) The client rendering is based on a ECS engine. So you can customize your displaying with custum entities. So, Client manage communication between server and user and also game rendering with ECS The customer has the: reception of different information sent by the server display of various asserts retrieve various user inputs and send them to the server set up an attractive client interface (GUI) integration of ECS with client","title":"What it's all about"},{"location":"Client/#how-it-works","text":"Run the executable r-type_client on Linux and r-type_client.exe on Windows","title":"How it works"},{"location":"Compile_and_Run/","text":"Dependencies CMake Installation Conan Installation Install Microsoft Visual C++ and MSBuild Tools packages Compiling and Running On Linux Run conan install . --build=missing at the root of your build directory Install the missing packages Create the directory \"build\" and go in Run cmake .. -DCMAKE_BUILD_TYPE=Release and after that run make On Windows Configure the Path for MSBuild Tools Run conan install . --build=missing -of=build at the root of your build directory Enter in the build directory with cd build Run cmake .. -DCMAKE_BUILD_TYPE=Release -G \"Visual Studio 17\" Run cmake --build . --config Release","title":"Compiling and Running"},{"location":"Compile_and_Run/#dependencies","text":"CMake Installation Conan Installation Install Microsoft Visual C++ and MSBuild Tools packages","title":"Dependencies"},{"location":"Compile_and_Run/#compiling-and-running","text":"","title":"Compiling and Running"},{"location":"Compile_and_Run/#on-linux","text":"Run conan install . --build=missing at the root of your build directory Install the missing packages Create the directory \"build\" and go in Run cmake .. -DCMAKE_BUILD_TYPE=Release and after that run make","title":"On Linux"},{"location":"Compile_and_Run/#on-windows","text":"Configure the Path for MSBuild Tools Run conan install . --build=missing -of=build at the root of your build directory Enter in the build directory with cd build Run cmake .. -DCMAKE_BUILD_TYPE=Release -G \"Visual Studio 17\" Run cmake --build . --config Release","title":"On Windows"},{"location":"How_to_use_Engine_based_on_ECS/","text":"How it works Our Engine is based on ECS (Entity Component System) and actually is used both on Client and Server. ` enum SYSTEM_TAG { render, event, network, update, user_handling, move, shots, destruction, }; class registry { public: using system = std::function ; using sparseArrayMap = std::unordered_map ; using systems = std::vector >; registry() { state = 0; } /*------------------------------------------>Start Component Management <-----------------------------------------------------------*/ template <class Component> void register_component() { _components_arrays[std::type_index(typeid(Component))] = std::any(sparse_array<Component>()); } template <typename Component> sparse_array<Component> &get_components() { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]); } template <typename Component> Component &get_component(entity entt) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return *(std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]))[entt]; } template <typename Component> void attach_component(entity entt, Component component) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to insert not exist\" << std::endl; throw std::exception(); } std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).insert_at(entt, component); } template <typename... Args> void attach_components(entity entt, Args... args) { ((attach_component(entt, args)), ...); } template <class Component> void detach_component(entity entt, Component component) { std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).erase(entt); } template <typename... Args> void detach_components(entity entt, Args... args) { ((detach_component(entt, args)), ...); } /*------------------------------------------>End Component Management <-----------------------------------------------------------*/ /*------------------------------------------>Start Entity Management <-----------------------------------------------------------*/ entity spawn_entity() { entity id; if (!killed.empty()) { id = killed.back(); killed.pop_back(); return id; } id = (_entities.empty()) ? entity(0) : entity(_entities.back() + 1); _entities.push_back(id); return id; } void kill_entity(entity entt) { killed.push_back(entt); } int entities() const { return _entities.size(); } template <typename type> static bool contains(std::vector<type> list, type element) { return (std::find(list.begin(), list.end(), element) != list.end()); } /*------------------------------------------>End Entity Management <-----------------------------------------------------------*/ /*------------------------------------------>Start System Management <-----------------------------------------------------------*/ void add_system(system const &f, SYSTEM_TAG tag) { _systems.push_back(std::make_pair(f, tag)); } void run_systems(SYSTEM_TAG tag) { for (auto const &_sys : _systems) { if (_sys.second == tag) _sys.first(*this); } } /*------------------------------------------>End Systems Management <-----------------------------------------------------------*/ bool isEntityUnusable(entity id) { return std::find(killed.begin(), killed.end(), id) != killed.end(); } void setState(int state) { this->state = state; } int getState(void) const { return state; } The main logic of ECS is based on the addition of components and customized systems, where all components of the same type are grouped together in a container. In this way, systems can more easily retrieve all the components on which they act, independently of the entities with which they are associated. This results in a consequent optimization of the program. To add a new component type, execute the register_component function. To create an entity, execute spawn_enity . And when you want to attach a component to the entity you've created, you execute attach_component . Here's an example: core.register_component<COMPONENT::Drawable>() core.register_component<COMPONENT::State>(); core.register_component<COMPONENT::Transformable>(); core.add_system(SYSTEM::render, SYSTEM_TAG::render); core.add_system(SYSTEM::manageTransformation, SYSTEM_TAG::update); core.attach_components(background, COMPONENT::Drawable(std::make_shared<sf::Sprite>(sf::Sprite(textures[0])))), COMPONENT::Transformable(sf::Vector2f(0, 0)), COMPONENT::State(0));","title":"How to use Engine based on ECS"},{"location":"How_to_use_Engine_based_on_ECS/#how-it-works","text":"Our Engine is based on ECS (Entity Component System) and actually is used both on Client and Server. ` enum SYSTEM_TAG { render, event, network, update, user_handling, move, shots, destruction, }; class registry { public: using system = std::function ; using sparseArrayMap = std::unordered_map ; using systems = std::vector >; registry() { state = 0; } /*------------------------------------------>Start Component Management <-----------------------------------------------------------*/ template <class Component> void register_component() { _components_arrays[std::type_index(typeid(Component))] = std::any(sparse_array<Component>()); } template <typename Component> sparse_array<Component> &get_components() { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]); } template <typename Component> Component &get_component(entity entt) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to get not exist\" << std::endl; throw std::exception(); } return *(std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]))[entt]; } template <typename Component> void attach_component(entity entt, Component component) { if (_components_arrays.find(std::type_index(typeid(Component))) == 0) { std::cerr << \"Component type you try to insert not exist\" << std::endl; throw std::exception(); } std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).insert_at(entt, component); } template <typename... Args> void attach_components(entity entt, Args... args) { ((attach_component(entt, args)), ...); } template <class Component> void detach_component(entity entt, Component component) { std::any_cast<sparse_array<Component> &>(_components_arrays[std::type_index(typeid(Component))]).erase(entt); } template <typename... Args> void detach_components(entity entt, Args... args) { ((detach_component(entt, args)), ...); } /*------------------------------------------>End Component Management <-----------------------------------------------------------*/ /*------------------------------------------>Start Entity Management <-----------------------------------------------------------*/ entity spawn_entity() { entity id; if (!killed.empty()) { id = killed.back(); killed.pop_back(); return id; } id = (_entities.empty()) ? entity(0) : entity(_entities.back() + 1); _entities.push_back(id); return id; } void kill_entity(entity entt) { killed.push_back(entt); } int entities() const { return _entities.size(); } template <typename type> static bool contains(std::vector<type> list, type element) { return (std::find(list.begin(), list.end(), element) != list.end()); } /*------------------------------------------>End Entity Management <-----------------------------------------------------------*/ /*------------------------------------------>Start System Management <-----------------------------------------------------------*/ void add_system(system const &f, SYSTEM_TAG tag) { _systems.push_back(std::make_pair(f, tag)); } void run_systems(SYSTEM_TAG tag) { for (auto const &_sys : _systems) { if (_sys.second == tag) _sys.first(*this); } } /*------------------------------------------>End Systems Management <-----------------------------------------------------------*/ bool isEntityUnusable(entity id) { return std::find(killed.begin(), killed.end(), id) != killed.end(); } void setState(int state) { this->state = state; } int getState(void) const { return state; } The main logic of ECS is based on the addition of components and customized systems, where all components of the same type are grouped together in a container. In this way, systems can more easily retrieve all the components on which they act, independently of the entities with which they are associated. This results in a consequent optimization of the program. To add a new component type, execute the register_component function. To create an entity, execute spawn_enity . And when you want to attach a component to the entity you've created, you execute attach_component . Here's an example: core.register_component<COMPONENT::Drawable>() core.register_component<COMPONENT::State>(); core.register_component<COMPONENT::Transformable>(); core.add_system(SYSTEM::render, SYSTEM_TAG::render); core.add_system(SYSTEM::manageTransformation, SYSTEM_TAG::update); core.attach_components(background, COMPONENT::Drawable(std::make_shared<sf::Sprite>(sf::Sprite(textures[0])))), COMPONENT::Transformable(sf::Vector2f(0, 0)), COMPONENT::State(0));","title":"How it works"},{"location":"Server/","text":"What it's all about It enables game interaction so that multiple players can connect The customer has the: customer login and logout serialize and deserialize data sent and received compression of sent and received data integration of ECS with server How it works Run the executable r-type_server on Linux and r-type_server.exe on Windows","title":"Server"},{"location":"Server/#what-its-all-about","text":"It enables game interaction so that multiple players can connect The customer has the: customer login and logout serialize and deserialize data sent and received compression of sent and received data integration of ECS with server","title":"What it's all about"},{"location":"Server/#how-it-works","text":"Run the executable r-type_server on Linux and r-type_server.exe on Windows","title":"How it works"}]}